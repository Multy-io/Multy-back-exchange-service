package core

import (
	"time"
	"github.com/Appscrunch/Multy-back-exchange-service/api"
	"fmt"
	"encoding/json"
	"github.com/Appscrunch/Multy-back-exchange-service/currencies"
	"strconv"
	"strings"
)

//type AutoGenerated struct {
//	Error  []interface{} `json:"error"`
//	Result struct {
//		BCHEUR struct {
//			A []string `json:"a"`
//			B []string `json:"b"`
//			C []string `json:"c"`
//			V []string `json:"v"`
//			P []string `json:"p"`
//			T []int    `json:"t"`
//			L []string `json:"l"`
//			H []string `json:"h"`
//			O string   `json:"o"`
//		} `json:"BCHEUR"`
//	} `json:"result"`
//}

type KrakenCoinResult struct {
			A []string `json:"a"`
			B []string `json:"b"`
			C []string `json:"c"`
			V []string `json:"v"`
			P []string `json:"p"`
			T []int    `json:"t"`
			L []string `json:"l"`
			H []string `json:"h"`
			O string   `json:"o"`
		}

type KrakenTicker struct {
	Error  []interface{} `json:"error"`
	Result map[string]*KrakenCoinResult `json:"result"`
}


type KrakenManager struct {
	BasicManager
	krakenApi    *api.KrakenApi
}


func (b *KrakenManager) StartListen(exchangeConfiguration ExchangeConfiguration, resultChan chan Result) {

	b.tickers = make(map[string]Ticker)
	b.krakenApi = api.NewKrakenApi()
	//b.symbolsToParse = b.composeSybolsToParse(exchangeConfiguration)
	//b.setchannelids()

	pairs := exchangeConfiguration.Pairs

	//ch := make(chan api.Reposponse)

	responseCh := make(chan api.RestApiReposponse)
	errorCh := make(chan error)

	b.listen(pairs, responseCh, errorCh)
	b.startSendingDataBack(exchangeConfiguration, resultChan)

	for {
		select {
		case err := <-errorCh:
			fmt.Println(err)
		case response := <-responseCh:
			//fmt.Printf("%s %@ %@ \n", response.Message, response.Pair.TargetCurrency.CurrencyCode(), response.Pair.ReferenceCurrency.CurrencyCode())
			if response.Message != nil {

				var krakenTicker KrakenTicker
				json.Unmarshal(response.Message, &krakenTicker)

				targetCode := response.Pair.TargetCurrency.CurrencyCode()
				referenceCode := response.Pair.ReferenceCurrency.CurrencyCode()

				if targetCode == "BTC" {
					targetCode = "XBT"
				}

				if  referenceCode == "USDT" {
					referenceCode = "USD"
				} else if referenceCode == "BTC" {
					referenceCode = "XBT"
				}

				for k, v :=range  krakenTicker.Result {
					//fmt.Println(k,v)
					//fmt.Println(targetCode, referenceCode)


					if  strings.Contains(k, targetCode) &&  strings.Contains(k, referenceCode) {
						//fmt.Println("int")
						//fmt.Println(krakenTicker.Result[symbol])
						//upbitTicker := upbitTickers[0]
						var ticker Ticker
						ticker.Rate, _ = strconv.ParseFloat(v.C[0], 64)
						ticker.TimpeStamp = time.Now()
						ticker.Pair = response.Pair
						//fmt.Println(ticker.Rate)
						b.Lock()
						b.tickers[ticker.Pair.Symbol()] = ticker
						b.Unlock()

					}

				}


			}

		}


	}

}

func (b *KrakenManager) listen(pairs []currencies.CurrencyPair, responseCh chan api.RestApiReposponse, errorCh chan error) {
	go func() {
		for range time.Tick(5 * time.Second) {
			for _, paiar := range pairs {
				go b.krakenApi.GetTicker(paiar, responseCh, errorCh)
			}
		}
	}()
}

func (b *KrakenManager) startSendingDataBack(exchangeConfiguration ExchangeConfiguration, resultChan chan Result) {
	go func() {
		for range time.Tick(1 * time.Second) {
			func() {
				tickers := []Ticker{}

				b.Lock()
				for _, value := range b.tickers {
					if value.TimpeStamp.After(time.Now().Add(-maxTickerAge * time.Second)) {
						tickers = append(tickers, value)
					}
				}
				b.Unlock()

				var tickerCollection = TickerCollection{}
				tickerCollection.TimpeStamp = time.Now()
				tickerCollection.Tickers = tickers
				//fmt.Println(tickerCollection)
				if len(tickerCollection.Tickers) > 0 {
					resultChan <- Result{exchangeConfiguration.Exchange.String(), &tickerCollection, nil}
				}
			}()
		}
	}()
}